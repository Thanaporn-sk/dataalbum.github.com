<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <title>Weather</title>
	<style>

	#forecastHeader {    
		position:absolute;
		top:20px;
		left:20px;
		width:640px;
		height:120px;
		font: 100% Helvetica;
		/*background: rgba(0, 0, 0, 0.2); /*The transparency will only be applied to the background*/
	
	}

	
	#forecast {    
		position:absolute;
		top:140px;
		left:20px;
		width:640px;
		height:300px;
		font: 100% Helvetica;
		/*background: rgba(0, 0, 0, 0.2); /*The transparency will only be applied to the background*/
	
	}
	
	#observation {    
		position:absolute;
		top:440px;
		left:20px;
		width:640px;
		height:200px;
		font: 100% Helvetica;
		/*background: rgba(0, 0, 0, 0.2); /*The transparency will only be applied to the background*/
	}


	</style>

    <!-- JavaScript -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script type="text/javascript" src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>

    <!-- Parser JavaScript files -->
    <script type="text/javascript" src="src/utils-1.0.0-min.js"></script>
    <script type="text/javascript" src="src/wfsrequestparser-1.0.0-min.js"></script>
    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?sensor=false"></script> 

    <script type="text/javascript">
        // Stored query ids.
        var STORED_QUERY_OBSERVATION = "fmi::observations::weather::multipointcoverage";
        var STORED_QUERY_FORECAST = "fmi::forecast::hirlam::surface::point::multipointcoverage";

        // URL for server and your api key.
        var server_url = "http://data.fmi.fi/fmi-apikey/516006c7-30ef-4474-97ea-76f7bf4ae01c/wfs";
        
		var weatherSymbols = [
				{"id":1,"name":"selkeää"},
				{"id":2,"name":"puolipilvistä"},
				{"id":21,"name":"heikkojasadekuuroja"},
				{"id":22,"name":"sadekuuroja"},
				{"id":23,"name":"voimakkaitasadekuuroja"},
				{"id":3,"name":"pilvistä"},
				{"id":31,"name":"heikkoavesisadetta"},
				{"id":32,"name":"vesisadetta"},
				{"id":33,"name":"voimakastavesisadetta"},
				{"id":41,"name":"heikkojalumikuuroja"},
				{"id":42,"name":"lumikuuroja"},
				{"id":43,"name":"voimakkaitalumikuuroja"},
				{"id":51,"name":"heikkoalumisadetta"},
				{"id":52,"name":"lumisadetta"},
				{"id":53,"name":"voimakastalumisadetta"},
				{"id":61,"name":"ukkoskuuroja"},
				{"id":62,"name":"voimakkaitaukkoskuuroja"},
				{"id":63,"name":"ukkosta"},
				{"id":64,"name":"voimakastaukkosta"},
				{"id":71,"name":"heikkojaräntäkuuroja"},
				{"id":72,"name":"räntäkuuroja"},
				{"id":73,"name":"voimakkaitaräntäkuuroja"},
				{"id":81,"name":"heikkoaräntäsadetta"},
				{"id":82,"name":"räntäsadetta"},
				{"id":83,"name":"voimakastaräntäsadetta"},
				{"id":91,"name":"utua"},
				{"id":92,"name":"sumua"}
		];
		//map symbol id to name
		var symbolMap = {};
			weatherSymbols.forEach(function(d, i) {
			//console.log(d)
			symbolMap[d.id] = d.name;
		});
        
        //get location
        function getLocation() {
        	
  			if (navigator.geolocation) {
    			navigator.geolocation.getCurrentPosition(codeLatLng, errorFunction);
			} 
			
			function errorFunction(){
			    alert("Geocoder failed");
			}
			
			function codeLatLng(position) {
			    var lat = position.coords.latitude;
			    var lng = position.coords.longitude;
			    
				var geocoder = new google.maps.Geocoder();
			    var latlng = new google.maps.LatLng(lat, lng);
			    geocoder.geocode({'latLng': latlng}, function(results, status) {
			      if (status == google.maps.GeocoderStatus.OK) {
			      console.log(results)
			        if (results[1]) {
			         	//2nd address component
						city = results[0].address_components[2].long_name;
         				console.log(city)
						localForecastHeader(server_url, city);
						localForecast(server_url, city);
						localObservation(server_url, city);
			        } else {
			          alert("No results found");
			        }
			      } else {
			        alert("Geocoder failed due to: " + status);
			      }
				});
		  	}
        }
		
		function showObservation(dataset,errors){

			console.log(dataset)
			
			var width = 640,
    			height = 200;
			
			var arrData = dataset.locations;
			console.log(arrData)
			
			var last = d3.min(dataset.locations[0].data.temperature.timeValuePairs, function(d) { return d.value; });
			console.log(last)

			var svg = d3.select('#observation').append('svg')
			    .attr('width', width)
			    .attr('height', height);

			var data = svg.selectAll("g")
				.data(arrData)
				.enter().append("g")  
				.attr('transform', function(d, i){return 'translate('+(i*50)+', 40)';});
			
			var content = data.selectAll("content")
				.data(function(d) {return d.data.temperature.timeValuePairs;})
				.enter().append("text")
				.text(function(d, i){return d.time = d3.time.format("%a %H:%M")(new Date(d.time)) + " | " + d.value + "°C";})
				.attr("dx", 0)
				.attr('dy', function(d, i){return (i+1)*20;});	
			
			var info = svg.selectAll(".info")
				.data(arrData)
				.enter().append("g")  
				.attr('transform', function(d, i){return 'translate('+(i*50)+', 0)';})
				
			info.append("text")
				.attr("dx", 0)
				.attr("dy", 30)
				.style("font-size", "150%")
				.text(function(d, i){ return "Observations | " + d.info.name; });

		};

		function showForecast(dataset,errors){

			console.log(dataset)
    					
			var width = 640,
    			height = 300;
			
			var arrData = dataset.locations;


			var shiftedTemp = dataset.locations[0].data.temperature.timeValuePairs.shift();
			var shiftedPress = dataset.locations[0].data.pressure.timeValuePairs.shift();
			var shiftedSymb = dataset.locations[0].data.weathersymbol3.timeValuePairs.shift();
			var shiftedWindD = dataset.locations[0].data.winddirection.timeValuePairs.shift();
			
			console.log(arrData)

			var svg = d3.select('#forecast').append('svg')
			    .attr('width', width)
			    .attr('height', height);

			var data = svg.selectAll("g")
				.data(arrData)
				.enter().append("g")  
				.attr('transform', function(d, i){return 'translate('+(i*50)+', 40)';});
			
			var content = data.selectAll("content")
				.data(function(d) { return d3.nest().key(function(d) { 
					return d.time; }).entries(d.data.temperature.timeValuePairs.concat(d.data.pressure.timeValuePairs,d.data.weathersymbol3.timeValuePairs,d.data.winddirection.timeValuePairs));})
				.enter().append("text")
				.text(function(d, i){return d.values[0].time = d3.time.format("%a %H:%M")(new Date(d.values[0].time)) + " | " + d3.format('.0f')(d.values[0].value) + "°C" + " | " + symbolMap[d.values[2].value] + " | " + d.values[3].value + "°";})
				.attr("dx", 0)
				.attr('dy', function(d, i){return (i+1)*20;});		

			var info = svg.selectAll("info")
				.data(["Forecast | Next 12 hours"])
				.enter().append("text")
				.attr("dx", 0)
				.attr("dy", 30)
				.style("font-size", "150%")
				.text(function(d) { return d;});

		};

		function showForecastHeader(dataset,errors){

			console.log(dataset)
			
			var width = 640,
    			height = 90;
			
			var arrData = dataset.locations;
			console.log(arrData)

			var shiftedTemp = dataset.locations[0].data.temperature.timeValuePairs.shift();
			var shiftedPress = dataset.locations[0].data.pressure.timeValuePairs.shift();
			var shiftedSymb = dataset.locations[0].data.weathersymbol3.timeValuePairs.shift();
			
			console.log(shiftedSymb)
			
			var svg = d3.select('#forecastHeader').append('svg')
			    .attr('width', width)
			    .attr('height', height);

			var data = svg.selectAll("g")
				.data(arrData)
				.enter().append("g")  
			
			var info = svg.selectAll("info")
				.data(arrData)
				.enter();

			info.append("text")
				.attr("dx", 0)
				.attr("dy", 30)
				.style("font-size", "250%")
				.text(function(d){ return d.info.name; });

			info.append("text")
				.attr("dx", 0)
				.attr("dy", 80)
				.style("font-size", "250%")
				.text(function(d){ return d3.format('.0f')(d.data.temperature.timeValuePairs[0].value) + "°C | " + symbolMap[d.data.weathersymbol3.timeValuePairs[0].value]; });

			info.append("text")
				.attr("dx", 0)
				.attr("dy", 110)
				.text(function(d){ return d.data.temperature.timeValuePairs[0].time = d3.time.format("%A %d.%m.%Y %H:%M")(new Date(d.data.temperature.timeValuePairs[0].time)); });
		};

        function localForecastHeader(url, sites) {
            // See API documentation and comments from parser source code of
            // fi.fmi.metoclient.metolib.WfsRequestParser.getData function for the description
            // of function options parameter object and for the callback parameters objects structures.
            fi.fmi.metoclient.metolib.WfsRequestParser.getData({
                url : url,
                storedQueryId : STORED_QUERY_FORECAST,
                requestParameter : "temperature,pressure,weathersymbol3",
                begin : new Date(),
                end : new Date((new Date()).getTime() + 1 * 60 * 60 * 1000),
                timestep : 60 * 60 * 1000,
                sites : [sites],
                callback : function(data, errors) {
                    // Handle the data and errors object in a way you choose.
                    console.log(data)
                    // Here, we delegate the content for a separate handler function.
                    // See parser documentation from source code comments for more details.
                    //handleCallback(data, errors, "Forecast Oulu temperature");
                    showForecastHeader(data, errors);
                }
            });
        };

        function localForecast(url, sites) {
            // See API documentation and comments from parser source code of
            // fi.fmi.metoclient.metolib.WfsRequestParser.getData function for the description
            // of function options parameter object and for the callback parameters objects structures.
            fi.fmi.metoclient.metolib.WfsRequestParser.getData({
                url : url,
                storedQueryId : STORED_QUERY_FORECAST,
                requestParameter : "temperature,pressure,weathersymbol3,winddirection",
                begin : new Date(),
                end : new Date((new Date()).getTime() + 11 * 60 * 60 * 1000),
                timestep : 60 * 60 * 1000,
                sites : [sites],
                callback : function(data, errors) {
                    // Handle the data and errors object in a way you choose.
                    console.log(data)
                    // Here, we delegate the content for a separate handler function.
                    // See parser documentation from source code comments for more details.
                    //handleCallback(data, errors, "Forecast Oulu temperature");
                    showForecast(data, errors);
                }
            });
        };
        
		function localObservation(url, sites) {
            // See API documentation and comments from parser source code of
            // fi.fmi.metoclient.metolib.WfsRequestParser.getData function for the description
            // of function options parameter object and for the callback parameters objects structures.
            fi.fmi.metoclient.metolib.WfsRequestParser.getData({
                url : url,
                storedQueryId : STORED_QUERY_OBSERVATION,
                requestParameter : "temperature,pressure",
                // Integer values are used to init dates for older browsers.
                // (new Date("2013-05-10T08:00:00Z")).getTime()
                // (new Date("2013-05-12T10:00:00Z")).getTime()
                begin : new Date(),
                end : new Date(),
                timestep : 10 * 60 * 1000,
                sites : sites,
                callback : function(data, errors) {
                    // Handle the data and errors object in a way you choose.
                    console.log(data)
                    // Here, we delegate the content for a separate handler function.
                    // See parser documentation from source code comments for more details.
                    showObservation(data, errors);
                }
            });
        };

        $(function() {
            // Multiple stations and multiple observations.
            //localForecastTemperature(TEST_SERVER_URL);
            getLocation();
        });
    </script>
</head>
<html>
    <body>
    	<div id="forecastHeader"></div>
    	<div id="forecast"></div>
    	<div id="observation"></div>
    </body>
</html>